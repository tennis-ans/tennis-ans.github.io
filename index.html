<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TANS - Tennis Algebraic Notation System</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border-radius: 0 0 20px 20px;
            margin: 20px auto;
            max-width: 1200px;
            padding: 40px 40px 30px;
        }

        .hero {
            text-align: center;
            margin-bottom: 60px;
        }

        .hero h1 {
            font-size: 3.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #2E7D32, #4CAF50);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
        }

        .hero .subtitle {
            font-size: 1.3em;
            color: #666;
            font-weight: 400;
            margin-bottom: 30px;
        }

        .hero .description {
            font-size: 1.1em;
            color: #000;
            #max-width: 700px;
            margin: 0 auto 30px;
        }

        .data-link {
            display: inline-block;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            padding: 15px 30px;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .data-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        .tools-section {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin: 40px auto;
            max-width: 1200px;
        }

        .tools-section h2 {
            font-size: 2.2em;
            color: #333;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 600;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .tool-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            border-left: 5px solid #4CAF50;
            transition: all 0.3s ease;
        }

        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .tool-card h3 {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .tool-card p {
            color: #666;
            margin-bottom: 20px;
        }

        .tool-link {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 12px 25px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tool-link:hover {
            background: #2E7D32;
            transform: translateX(5px);
        }

        .tip {
            background: #e8f5e8;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            border-left: 4px solid #4CAF50;
        }

        .tip strong {
            color: #2E7D32;
        }

        .tip code {
            background: #c8e6c9;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', monospace;
            color: #1B5E20;
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5em;
            }
            
            .hero .subtitle {
                font-size: 1.1em;
            }
            
            .header, .tools-section {
                margin: 10px;
                padding: 20px;
            }
            
            .tools-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="hero">
            <h1>TANS: Tennis Algebraic Notation System</h1>
            <p class="description" style="text-align:left">TANS is a notation system for strategic analysis of tennis games, 
                inspired by the algebraic notation system of chess. Its concise encoding describes the positions of players 
                and the tennis ball, stroke type, point results, etc. It can be used for traditional statistical analysis, 
                translation to other tennis descriptions, such as TennisAbstract. It also lays the foundation for AI-based 
                strategy analysis for tennis. 
                The paper describing TANS is published in <a href="https://formal-analysis.com/isace/2025/">the 2nd 
                    International Sports Analytics Conference and Exhibition (ISACE)</a>.
                <br><br>
                <b>Publication:</b><br>
                Yuexi Song, Chuanfei Li, Hao Cao, Ling Wu, Huanhuan Zheng, and Zhenkai Liang. "TANS: A Chess-Inspired 
                Notation System for Strategy Analysis of Tennis Games. In <i>the 2nd 
                    International Sports Analytics Conference and Exhibition (ISACE)</i>, Shanghai, September 2025. 
                    [<a href="publications/ISACE25-TANS.pdf">Paper</a>]
    
            </p>
            <a href="data" class="data-link">üìä Browse Match Data</a>
        </div>
    </div>

    <div class="tools-section">
        <h2>üõ†Ô∏è Analysis Tools</h2>
        <div class="tools-grid">
            <div class="tool-card">
                <h3>üìà Match Statistics Analyzer</h3>
                <p>Generate comprehensive match statistics from your charted TANS data. Analyze player patterns, shot distributions, and tactical insights.</p>
                <div id="analysis-upload" style="margin-bottom:20px;">
                    <input type="file" id="fileInput" accept=".txt" style="display:none">
                    <div id="dropZone" style="border:2px dashed #4CAF50; border-radius:10px; padding:30px; text-align:center; background:#e8f5e8; color:#2E7D32; cursor:pointer;">
                        <strong>Drag & drop your TANS .txt file here, or click to select</strong>
                    </div>
                </div>
                <div id="analysisResults" style="background:#f8f9fa; border-radius:10px; padding:20px; margin-top:10px; color:#333; display:none;"></div>
            </div>
            
            <div class="tool-card">
                <h3>üîÑ TennisAbstract Converter</h3>
                <p>Export your TANS charted data into TennisAbstract's format for compatibility with existing tennis analysis tools.</p>
                <div id="convert-upload" style="margin-bottom:20px;">
                    <input type="file" id="convertFileInput" accept=".txt" style="display:none">
                    <div id="convertDropZone" style="border:2px dashed #4CAF50; border-radius:10px; padding:30px; text-align:center; background:#e8f5e8; color:#2E7D32; cursor:pointer;">
                        <strong>Drag & drop your TANS .txt file here, or click to select</strong>
                    </div>
                </div>
                <div id="convertResults" style="background:#f8f9fa; border-radius:10px; padding:20px; margin-top:10px; color:#333; display:none;"></div>
            </div>
        </div>
    </div>
    <script>
    // --- Drag & Drop UI ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const analysisResults = document.getElementById('analysisResults');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', e => {
        e.preventDefault();
        dropZone.style.background = '#C8E6C9';
    });
    dropZone.addEventListener('dragleave', e => {
        dropZone.style.background = '#e8f5e8';
    });
    dropZone.addEventListener('drop', e => {
        e.preventDefault();
        dropZone.style.background = '#e8f5e8';
        handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', e => {
        if (fileInput.files.length) handleFile(fileInput.files[0]);
    });

    function handleFile(file) {
        if (!file || !file.name.endsWith('.txt')) {
            analysisResults.style.display = 'block';
            analysisResults.innerHTML = '<span style="color:red">Please upload a .txt file.</span>';
            return;
        }
        const reader = new FileReader();
        reader.onload = function(e) {
            const lines = e.target.result.split(/\r?\n/);
            runAnalysis(lines);
        };
        reader.readAsText(file);
    }

    // --- Analysis Logic (JS port of your Python) ---
    function extractRalliesByTime(lines) {
        const rallies = [];
        let current = [];
        for (let line of lines) {
            line = line.trim();
            if (line.startsWith('# Time')) {
                if (current.length) {
                    rallies.push(current);
                    current = [];
                }
            }
            if (line && !line.startsWith('[')) {
                current.push(line);
            }
        }
        if (current.length) rallies.push(current);
        return rallies;
    }

    function analyzeServingPoint(rallies) {
        let totalPoints = 0, serverWon = 0;
        for (let rally of rallies) {
            let winner = null, winnerLineIndex = null;
            for (let j = 0; j < rally.length; ++j) {
                if (/^[XYZW][VF]$/.test(rally[j])) {
                    winner = rally[j][0];
                    winnerLineIndex = j;
                    break;
                }
            }
            if (winnerLineIndex !== null) {
                for (let k = 0; k < winnerLineIndex; ++k) {
                    const match = rally[k].match(/\d+\.\s*([^\(]+)/);
                    if (match) {
                        const pointId = match[1].trim().split(',')[0];
                        const server = pointId[0];
                        totalPoints++;
                        if (winner === 'X' && ['X','Y'].includes(server)) serverWon++;
                        else if (winner === 'Z' && ['Z','W'].includes(server)) serverWon++;
                        break;
                    }
                }
            }
        }
        return totalPoints > 0 ? serverWon / totalPoints : 0;
    }

    function extractLastShots(rallies) {
        let totalPoints = 0, forehandWinner = 0, backhandWinner = 0;
        for (let rally of rallies) {
            let winnerLineIndex = null;
            for (let j = 0; j < rally.length; ++j) {
                if (/^[XYZW][VF]$/.test(rally[j])) {
                    winnerLineIndex = j;
                    break;
                }
            }
            if (winnerLineIndex !== null && winnerLineIndex > 0) {
                totalPoints++;
                const lastShotLine = rally[winnerLineIndex - 1];
                const match = lastShotLine.match(/\d+\.\s*([^\(]+)/);
                if (match) {
                    const itemsStr = match[1].trim();
                    const items = itemsStr.split(',').map(item => item.trim());
                    forehandWinner += items.filter(item => item.includes('f')).length;
                    backhandWinner += items.filter(item => item.includes('b')).length;
                }
            }
        }
        return [totalPoints, forehandWinner, backhandWinner];
    }

    function runAnalysis(lines) {
        const rallies = extractRalliesByTime(lines);
        const [totalPoints, forehandWinner, backhandWinner] = extractLastShots(rallies);
        const servingSideWin = analyzeServingPoint(rallies);
        analysisResults.style.display = 'block';
        analysisResults.innerHTML = `<strong>Analysis Results:</strong><br>
            Total points analyzed: <b>${totalPoints}</b><br>
            Forehand winners percentage: <b>${(forehandWinner/totalPoints*100).toFixed(2)}%</b><br>
            Backhand winners percentage: <b>${(backhandWinner/totalPoints*100).toFixed(2)}%</b><br>
            Serving side winning percentage: <b>${(servingSideWin*100).toFixed(2)}%</b>`;
    }

    // --- Drag & Drop UI for Converter ---
    const convertDropZone = document.getElementById('convertDropZone');
    const convertFileInput = document.getElementById('convertFileInput');
    const convertResults = document.getElementById('convertResults');

    convertDropZone.addEventListener('click', () => convertFileInput.click());
    convertDropZone.addEventListener('dragover', e => {
        e.preventDefault();
        convertDropZone.style.background = '#C8E6C9';
    });
    convertDropZone.addEventListener('dragleave', e => {
        convertDropZone.style.background = '#e8f5e8';
    });
    convertDropZone.addEventListener('drop', e => {
        e.preventDefault();
        convertDropZone.style.background = '#e8f5e8';
        handleConvertFile(e.dataTransfer.files[0]);
    });
    convertFileInput.addEventListener('change', e => {
        if (convertFileInput.files.length) handleConvertFile(convertFileInput.files[0]);
    });

    function handleConvertFile(file) {
        if (!file || !file.name.endsWith('.txt')) {
            convertResults.style.display = 'block';
            convertResults.innerHTML = '<span style="color:red">Please upload a .txt file.</span>';
            return;
        }
        const reader = new FileReader();
        reader.onload = function(e) {
            const lines = e.target.result.split(/\r?\n/);
            const output = runConvert(lines);
            downloadConvertedFile(output, `converted_${file.name}.txt`);
            convertResults.style.display = 'block';
            convertResults.innerHTML = '<strong>Conversion complete!</strong> Your file has been downloaded.';
        };
        reader.readAsText(file);
    }

    // --- Converter Logic (JS port of your Python) ---
    function transformBlock(blockLines) {
        const result = [];
        for (let line of blockLines) {
            line = line.trim();
            // Handle "s" shots
            let sMatch = line.match(/\d+\.\s+[XY]s([A-Z])/);
            if (sMatch) {
                const letter = sMatch[1];
                if (["A", "E"].includes(letter)) result.push("4");
                else if (["B", "D"].includes(letter)) result.push("5");
                else if (letter === "C") result.push("6");
                else result.push("?");
                continue;
            }
            // Handle other shot types
            let shotMatch = line.match(/\d+\.\s+[XY]([a-z]+)([A-Z])(\d+)/);
            if (shotMatch) {
                let shotCode = shotMatch[1].replace("r", "s");
                let letter = shotMatch[2];
                let number = parseInt(shotMatch[3]);
                result.push(shotCode);
                if (number >= 5) {
                    if (["A", "B"].includes(letter)) result.push("1");
                    else if (["E", "D"].includes(letter)) result.push("3");
                    else if (letter === "C") result.push("2");
                    else result.push("?");
                } else {
                    if (["D", "E"].includes(letter)) result.push("1");
                    else if (["A", "B"].includes(letter)) result.push("3");
                    else if (letter === "C") result.push("2");
                    else result.push("?");
                }
                continue;
            }
            // Endings like XV, YF
            if (line.endsWith("V")) result.push("*");
            else if (line.endsWith("F")) result.push("#");
        }
        return result.join("");
    }

    function runConvert(lines) {
        const outputLines = [];
        let currentTime = null;
        let currentBlock = [];
        for (let line of lines) {
            line = line.trim();
            if (line.startsWith("# Time:")) {
                if (currentTime !== null) {
                    const transformed = transformBlock(currentBlock);
                    outputLines.push(`${currentTime} ${transformed}`);
                }
                currentTime = line;
                currentBlock = [];
            } else if (line) {
                currentBlock.push(line);
            }
        }
        // Final block
        if (currentTime !== null) {
            const transformed = transformBlock(currentBlock);
            outputLines.push(`${currentTime} ${transformed}`);
        }
        return outputLines.join("\n");
    }

    function downloadConvertedFile(content, filename) {
        const blob = new Blob([content], {type: 'text/plain'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    </script>
</body>
</html>

